Nikki Woo 204927670

answers.txt

12.17
A- The main function does not return anything because, in the created thread that runs the function f that is supposed to sleep for 1 second and print a string, the main function does not allow the thread to run the function because it calls the Linux exit function immediately after. By calling the Linux exit function right after creating the thread, the main process and all the threads associated with the process are terminated and thus the function f has no opportunity to run before the main process exits thus terminating the thread.
B- We can fix this problem by replacing the exit(0) function called in main with the pthread_exit function which waits for all peer threads to terminate before terminating the main thread. With this exit function, the program will wait for the function f called with the created thread to run and terminate before terminating the main thread. We can also call pthread_join passing in the created thread tid. The join function blocks until the thread terminates so it allows the thread to run the function f to completion before terminating.

12.25
The function is thread safe but is not reentrant. We first analyze how it is thread safe by looking at the four classes of thread-unsafe functions as reported by the book. We know from observing that the echo_cnt function uses a mutex that the function passes out of class one which consists of functions that do not protect shared variables. Furthermore, we know that the echo_cnt function does not keep state across multiple invocation and does not return a pointer to a static variable. Finally, we check to see that the function does not call any other thread-unsafe functions. Checking through all the functions called by echo_cnt we see that all are thread safe. We know that Pthread_once calls the init_echo_cnt function once and that merely initializes the semaphore and byte count. Since it is called only once, it is not thread unsafe. Furthermore, rio_readinitb, rio_readlineb, and rio_writen are thread-safe as defined in section 10.5 of the textbook. Thus, since echo_cnt does not violate any of the condition set forth by unsafe thread classes, we know that it is thread safe. However, we know that the function is not reentrant because echo_cnt DOES reference shared data when called by multiple threads in the form of the byte_cnt variable used to keep track of total bytes read by the server.
